[1000. Minimum Cost to Merge Stones](https://leetcode.com/problems/minimum-cost-to-merge-stones/)

* Amazon, Google
* Dynamic Programming
* Similar Questions:
    * [312. Burst Balloons](https://leetcode.com/problems/burst-balloons/)
    * Minimum Cost to Connect Sticks
    
    
## Method 1. [[Java/C++/Python] DP](https://leetcode.com/problems/minimum-cost-to-merge-stones/discuss/247567/JavaC%2B%2BPython-DP)
Key Points:
1. For each merging, `(K-1)` elements will be removed. For the last `K` elements, after merging, only `1` element will be 
left, therefore, there are `N-1` elements which will be removed during the merging process. 
Therefore, if `(N-1) % (K-1) != 0`, there must have extra elements that cannot be removed.
2. `dp[i][j]` means the minimum cost needed to merge the range `stones[i],...,stones[j]`, both `i` and `j` inclusive, 
to the minimum possible piles (this is one or more piles). `stones[i,...,j]` might or might not cover a range that is mergeable
into one pile and the minimum pile is deterministic based on the range length.
3. How to compose each `dp[i][j]` from the smaller subproblem:
    1. To merge `stones[i,j]` to min number of piles, find all valid `mid` s.t.(subject to) `dp[i, mid] + dp[mid+1,j]` gives
    the smallest cost. I.e., only looking at `mids = range(i,j,k-1)` which means all valid partitionings are exhausted.
    2. Whenever the `stones[i,j]` range is totally collapsable, collapse it into one pile ---> this is done via the 
    `prefix[j+1] - prefix[i]` step.
```java
class Solution {
    public int mergeStones(int[] stones, int K) {
        int n = stones.length;
        if ((n - 1) % (K - 1) > 0) return -1;

        int[] prefix = new int[n+1];
        for (int i = 0; i <  n; i++)
            prefix[i + 1] = prefix[i] + stones[i];

        int[][] dp = new int[n][n];
        for (int m = K; m <= n; ++m)
            for (int i = 0; i + m <= n; ++i) {
                int j = i + m - 1;
                dp[i][j] = Integer.MAX_VALUE;
                for (int mid = i; mid < j; mid += K - 1)
                    dp[i][j] = Math.min(dp[i][j], dp[i][mid] + dp[mid + 1][j]);
                if ((j - i) % (K - 1) == 0)
                    dp[i][j] += prefix[j + 1] - prefix[i];
            }
        return dp[0][n - 1];
    }
}
```


## Method 2. [Java DFS use Cached Result, aka, DP](https://leetcode.com/problems/minimum-cost-to-merge-stones/discuss/537926/Java-DFS-use-Cached-Result-aka-DP)
```java
class Solution {
    int n, k;
    long[][][] dp;
    int[] sum;
    int inf = Integer.MAX_VALUE;
    public int mergeStones(int[] ss, int K) {
        n = ss.length;
        k = K;
        if (n == 1) return 0;
        if ( (n - 1) % (k - 1) != 0) return -1;
        sum = new int[n + 1];
        dp = new long[n + 1][n + 1][n + 1];   //use n + 1 to avoid out of bound exception on cnt;
        for (int i = 0; i < n; i++) {
            sum[i + 1] = sum[i] + ss[i];
        }
        int res = (int) dfs(0, n - 1, 1);
        return res < inf ? res : -1;
    }
    
    private long dfs(int st, int ed, int cnt) {
        if (dp[st][ed][cnt] > 0) return dp[st][ed][cnt];
        long res = inf;
        if ((ed - st + 1 - cnt) % (k - 1) > 0) return inf;
        if (st == ed) res = cnt == 1 ? 0 : inf;  //if cnt == 1, cost is 0;
        else if (cnt == 1) res = dfs(st, ed, k) + sum[ed + 1] - sum[st];
        else {
            for (int i = st; i < ed; i++) {  //start from st, other than st + 1;
                res = Math.min(res, dfs(st, i, 1) + dfs(i+1, ed, cnt - 1));
            }
        }
        dp[st][ed][cnt] = res;
        return res;
    }
}
```


