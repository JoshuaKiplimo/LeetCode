[1087. Brace Expansion](https://leetcode.com/problems/brace-expansion/)

* Google
* Backtracking
* Similar Questions:
    * Decode String
    * Letter Case Permutation
    * Brace Expansion II
* Hints:
    * All generated strings are of the same size. How can we generate all of these strings?
    * Do a backtracking on which each level of it has to choose one single character (e.g. 'a') or any character of the given parenthesized group (e.g. "{a, b, c}").


## Method 1. DFS
```java 
class Solution {
    public String[] expand(String S) {
        if(S == null || S.length() == 0) {
            return new String[]{""};
        } else if(S.length() == 0) {    // Only one character
            return new String[]{S};
        }
        
        // TreeSet to sort
        TreeSet<String> set = new TreeSet<String>();
        if(S.charAt(0) == '{') {
            int i = 0;              // kep track of the content in the "{content}"
            while(S.charAt(i) != '}') {
                i++;
            }   // After the while loop, S.charAt(i) == '}'
            String subStr = S.substring(1, i);
            String[] subs = subStr.split(",");
            String[] subRes = expand(S.substring(i+1)); // dfs to get the res of rest substring
            for(String head: subs) {
                for(String tail: subRes) {
                    set.add(head + tail);
                }
            }
        } else {
            String[] subRes = expand(S.substring(1));
            for(String tail: subRes) {
                set.add(S.charAt(0) + tail);
            }
        }
        return set.toArray(new String[0]);
    }
}
```


## Method 2. DFS without TreeSet
```java 
class Solution {
    public String[] expand(String S) {
        if(S == null || S.length() == 0) {
            return new String[]{""};
        } else if(S.length() == 1) {
            return new String[]{S};
        }
        
        List<String> res = new ArrayList<String>();
        if(S.charAt(0) == '{') {
            int i = 0;  // index
            while(i < S.length()) {
                if(S.charAt(i) == '}') {
                    break;
                }
                i++;
            }
            String[] heads = S.substring(1, i).split(",");
            String[] tails = expand(S.substring(i + 1));
            for(String head: heads) {
                for(String tail: tails) {
                    res.add(head + tail);
                }
            }
        } else {
            String[] tails = expand(S.substring(1));
            for(String tail: tails) {
                res.add(S.charAt(0) + tail);
            }
        }
        Collections.sort(res);
        return res.toArray(new String[0]);
    }
}
```

## Method 3. Backtracking
```java 
class Solution {
    
    public String[] expand(String S) {
        if(S == null || S.length() == 0) {
            return new String[]{""};
        } else if(S.length() == 1) {
            return new String[]{S};
        }
        
        List<String> list = new ArrayList<String>();
        helper(0, S, list, new StringBuilder(), S.length());
        // Add list to string array
        Collections.sort(list);
        String[] res = new String[list.size()];
        for(int i=0; i<res.length; i++) {
            res[i] = list.get(i);
        }
        return res;
    }
    
    private void helper(int k, String S, List<String> list, StringBuilder sb, int len) {
        if(k == len) {
            list.add(sb.toString());
            return;
        }
        // Iterate over char inside {}
        int sLen = sb.length();
        if(S.charAt(k) == '{') {
            // Find loc of '}'
            int rt = k + 1;
            while(S.charAt(rt) != '}') {
                rt++;
            }   // After the while loop, S.charAt(rt) == '}'
            for(int i=k+1; i<rt; i++) {
                char c = S.charAt(i);
                if(c == ',') {
                    continue;
                }
                sb.append(S.charAt(i));
                helper(rt+1, S, list, sb, len);
                // Backtracking
                sb.setLength(sLen);
            }
        } else {    // Handle only a single char
            sb.append(S.charAt(k));
            helper(k+1, S, list, sb, len);
            sb.setLength(sLen);
        }
    }
}
```

## Reference:
1. [Java DFS](https://leetcode.com/problems/brace-expansion/discuss/312361/Java-DFS)


