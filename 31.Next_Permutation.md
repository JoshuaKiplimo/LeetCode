[31. Next Permutation](https://leetcode.com/problems/next-permutation/)

* Facebook, Microsoft, Amazon, ByteDance, Apple, Atlassian, Google, Adobe, eBay
* Array
* Similar Questions:
    * Permutations
    * Permutations II
    * Permutation Sequence
    * Palindrome Permutation II
    
    
## Method 1. Single Pass
> First, we observe that for any given sequence that is in descending order, no next larger permutation is possible.            
> [如果整个序列是降序的，则说明没有比现在更大的序列了。]
> ![nums graph](images/31_nums_graph.png)
```java 
class Solution {
    public void nextPermutation(int[] nums) {
        if(nums == null || nums.length < 2) {
            return;
        }
        
        int i = nums.length - 2;
        while(i >= 0 && nums[i] >= nums[i+1]) {
            i--;
        }   // After the while loop, nums[i] < nums[i+1]
        if(i == -1) {
            Arrays.sort(nums);
            return;
        }
        int j = nums.length - 1;
        while(j >= 0 && nums[i] >= nums[j]) {
            j--;
        }   // After the while loop, nums[i] < nums[j]
        
        swap(nums, i, j);
        Arrays.sort(nums, i+1, nums.length);
    }
    
    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```

## Method 2.
```java 
class Solution {
    public void nextPermutation(int[] nums) {
        if(nums==null || nums.length==0) {
            return;
        }
        
        int firstSmall = -1;
        for(int i=nums.length-2; i>=0; i--) {
            if(nums[i] < nums[i+1]) {
                firstSmall = i;
                break;
            }
        }
        
        if(firstSmall == -1) {
            reverse(nums, 0, nums.length-1);
            return;
        }
        
        int firstLarge = -1;
        for(int i=nums.length-1; i>firstSmall; i--) {
            if(nums[i] > nums[firstSmall]) {
                firstLarge = i;
                break;
            }
        }
        swap(nums, firstSmall, firstLarge);
        reverse(nums, firstSmall+1, nums.length-1);
    }
    
    private void reverse(int[] nums, int l, int r) {
        while(l < r) {
            swap(nums, l++, r--);
        }
    }
    
    private void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
}
```
