[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/)

* Uber, Google
* Backtracking
* Similar Questions:
    * Next Permutations
    * Permutations II
    * Palindrome Permutation
* Hints:
    * If a palindrome permutations exists, we just need to generate the first half of the string.
    * To generate all distinct permutations of a (half of) string, use a similar approach from: Permutations II or Next permutation.
    
    
## Method 1. Backtracking 
> It might be possible that no palindromic permutation could be possible for the given string `s`. [对于一个 String `s`，可能没有回文的组合。]         
> Firstly, we check if a palindromic permutation is possible for string `s`:
>   * If yes, then only we proceed further with generating the permutations.
> To check this, we make use of a `HashMap` which stores the number of occurrences of each character.
> If the number of characters with odd number of occurrences exceeds 1, it indicates that no palindromic permutation is possible for `s`.
>
> One idea is to generate only the first half of the palindromic string and to append its reverse string to itself to generate the full length palindromic string.
>
> In case of a string `s` with odd length, whose palindromic permutations are possible, one of the characters is `s` must be occurring an odd number of times. 
> We keep a track of this char, `ch`, and it is kept separate from the rest. 

```java 
class Solution {
    Set<String> set = new HashSet<String>();
    
    public List<String> generatePalindromes(String s) {
        int[] map = new int[128];
        char[] st = new char[s.length() / 2];
        if(!canPermutePalindrome(s, map)) {
            return new ArrayList<String>();
        }
        char ch = 0;
        int k = 0;
        for(int i=0; i<map.length; i++) {
            if(map[i] % 2 == 1) {
                ch = (char) i;
            }
            for(int j=0; j<map[i] / 2; j++) {
                st[k++] = (char)i;
            }
        }
        permute(st, 0, ch);
        return new ArrayList<String>(set);
    }
    
    public boolean canPermutePalindrome(String s, int[] map) {
        int count = 0;
        for(int i=0; i<s.length(); i++) {
            map[s.charAt(i)]++;
            if(map[s.charAt(i)] % 2 == 0) {
                count--;
            } else {
                count++;
            }
        }
        return count <= 1;
    }
    
    private void permute(char[] s, int l, char ch) {
        if(l == s.length) {
            set.add(new String(s) + (ch == 0 ? "" : ch) + new StringBuilder(new String(s)).reverse().toString());
        } else {
            for(int i=l; i<s.length; i++) {
                if(s[l] != s[i] || l == i) {
                    swap(s, l, i);
                    permute(s, l+1, ch);
                    swap(s, l, i);
                }
            }
        }
    }
    
    private void swap(char[] s, int i, int j) {
        char tmp = s[i];
        s[i] = s[j];
        s[j] = tmp;
    }
}
```

Complexity Analysis

    Time complexity : O((n/2 + 1)!). Atmost (n/2)! permutations need to be generated in the worst case. Further, for each permutation generated, string.reverse() function will take n/4 time.
    Space complexity : O(n). The depth of recursion tree can go upto n/2 in the worst case.


